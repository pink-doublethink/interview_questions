---
tags:
- Technology/BA
- Difficulty/Intermediate
---
----
## В каком сценарии вы выберете GraphQL вместо REST, и как решаете вопросы N+1 и кеширования
----
> [!FAQ]- Ответ
> - С точки зрения требований и архитектуры, я бы рекомендовал выбирать GraphQL вместо REST в сценариях, где доменная модель сильно взаимосвязана, а клиентским приложениям требуется гибкость, чтобы избежать избыточной или недостаточной выборки данных. Например, если мы разрабатываем мобильное приложение с ограничениями по пропускной способности, которому необходимо отображать профиль пользователя, его недавние заказы и статус доставки на одном экране, REST обычно потребовал бы нескольких обращений к различным конечным точкам или специальной конечной точки «бэкэнд для фронтенда». GraphQL решает эту проблему, позволяя клиенту запрашивать только необходимые поля за один сетевой вызов. Такой подход значительно отделяет итерации фронтенда от циклов разработки бэкэнда, позволяя заинтересованным сторонам быстрее видеть улучшения пользовательского интерфейса без необходимости постоянной корректировки схем API бэкэнда.
> - Для решения проблемы N+1 — распространенной проблемы производительности, когда получение списка родительских элементов вызывает отдельные запросы к базе данных для каждой дочерней записи — я уделяю особое внимание определению строгих нефункциональных требований (NFR) в отношении задержки и пропускной способности системы. В то время как команда разработчиков реализует решение, обычно используя библиотеки для пакетной обработки и кэширования, такие как DataLoader, для объединения запросов в один запрос к базе данных, моя роль заключается в обеспечении проверки этих ограничений производительности на этапах приемочного тестирования пользователями (UAT) и нагрузочного тестирования. Я бы выступал за включение анализа стоимости запросов в шлюз API, чтобы предотвратить истощение ресурсов из-за слишком сложных вложенных запросов, обеспечивая стабильность системы при высокой параллельной нагрузке.
> - Наконец, решение проблем кэширования в GraphQL требует отхода от стандартных методов REST, поскольку запросы GraphQL обычно используют одну конечную точку HTTP POST, что делает недействительным кэширование в браузере и CDN на основе URL-адресов. Чтобы смягчить это, я бы структурировал требования вокруг двухуровневой стратегии кэширования. На стороне клиента я бы указал использование нормализованных кэшей в состоянии приложения (с использованием таких инструментов, как Apollo Client) для предотвращения избыточных сетевых запросов. На стороне сервера, для данных, которые меняются нечасто, я бы предложил реализовать постоянные запросы (Persisted Queries). Этот метод позволяет присваивать уникальные идентификаторы определенным строкам запросов, эффективно превращая их в запросы GET, которые могут кэшироваться CDN или промежуточными прокси-серверами, тем самым балансируя гибкость GraphQL с эффективностью производительности, обычно ассоциируемой с REST.