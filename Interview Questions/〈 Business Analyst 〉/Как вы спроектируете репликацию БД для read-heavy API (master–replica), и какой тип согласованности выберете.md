---
tags:
- Technology/BA
- Difficulty/Intermediate
---
----
## Как вы спроектируете репликацию БД для read-heavy API (master–replica), и какой тип согласованности выберете
----
> [!FAQ]- Ответ
> - Для удовлетворения архитектурных требований к API с высокой нагрузкой на чтение я бы рекомендовал топологию репликации «Лидер-Последователь» (часто называемую «Мастер-Подчиненный»), которая напрямую поддерживает бизнес-цель высокой масштабируемости и пропускной способности. В этой конфигурации все транзакционные операции записи — такие как команды INSERT, UPDATE и DELETE — направляются на единственный первичный узел для обеспечения целостности данных и единого источника истины. Одновременно трафик чтения масштабируется горизонтально между несколькими репликами для чтения. Как бизнес-аналитик, я бы задокументировал эти спецификации как нефункциональные требования (NFR), уделяя особое внимание производительности системы, в частности, стремясь снизить нагрузку на основной экземпляр базы данных, чтобы предотвратить узкие места во время пиковой нагрузки. Такое разделение задач позволяет системе эффективно обрабатывать большой объем входящих запросов GET, не снижая доступность записи для основного приложения.
> - Что касается модели согласованности, решение во многом зависит от конкретной бизнес-области, но для стандартного API с высокой нагрузкой на чтение, где скорость имеет первостепенное значение, я бы рекомендовал модель конечной согласованности, обеспечиваемую асинхронной репликацией. Выбор строгой согласованности часто приводит к значительной задержке, поскольку операция записи должна распространиться на реплики, прежде чем будет подтверждена клиенту, что подрывает цели производительности высоконагруженного API. Принимая конечную согласованность, мы отдаем приоритет доступности и устойчивости к разделению — в соответствии с теоремой CAP — принимая при этом кратковременную задержку репликации, когда пользователь может столкнуться с немного устаревшими данными. Этот компромисс обычно приемлем для таких случаев использования, как каталоги товаров или социальные ленты, где точность до микросекунд менее важна, чем быстрое время отклика и удобство работы пользователя.
> - Для снижения операционных рисков, связанных с этой архитектурой, я бы определил строгие целевые показатели уровня обслуживания (SLO) относительно максимально допустимого времени распространения данных, гарантируя, что «устаревание» остается в пределах допустимых для бизнеса уровней. С точки зрения системного анализа, требования должны предусматривать использование балансировщика нагрузки на уровне API для интеллектуального распределения запросов на чтение между работоспособными репликами. Кроме того, на этапе приемочного тестирования пользователями (UAT) я бы убедился, что мы проверяем граничные случаи, когда данные еще не распространились, проверяя, что приложение корректно обрабатывает эти сценарии, не вызывая путаницы у пользователей или ошибок приложения. Такой комплексный подход гарантирует, что архитектура базы данных удовлетворяет как техническим ограничениям, так и стратегическим потребностям бизнеса.