---
tags:
- Technology/BA
- Difficulty/Intermediate
---
----
## Какие типы данных JSON вы используете в API-контрактах
----
> [!FAQ]- Ответ
> - При определении контрактов API, особенно в спецификациях типа OpenAPI или Swagger, я рассматриваю типы данных JSON не просто как технические ограничения, а как точные представления бизнес-правил, которые они должны поддерживать. На базовом уровне я использую стандартные примитивные типы — в частности, строки, числа, булевы значения и null — но с прикрепленной к ним точной логикой проверки. Например, простое обозначение поля как «строка» редко бывает достаточным для надежного документа с требованиями; я гарантирую, что контракт определяет такие ограничения, как шаблоны регулярных выражений (regex) для адресов электронной почты или определенную длину символов, соответствующую ограничениям схемы базы данных. Аналогично, при определении числовых типов я различаю целые числа и числа с плавающей запятой, чтобы предотвратить ошибки округления в финансовых расчетах, гарантируя, что структура данных идеально соответствует нефункциональным требованиям к целостности данных.
> - Помимо примитивов, я активно использую сложные структуры данных, в частности объекты и массивы, для моделирования иерархических связей, присущих бизнес-сущностям. Например, при проектировании конечной точки для профиля клиента я бы определил корневой объект JSON, содержащий вложенные объекты для «Адреса» или «платежных реквизитов» и массивы для «истории транзакций». В этих определениях я явно документирую кардинальность и необязательность полей — уточняя, какие атрибуты являются обязательными для действительности полезной нагрузки, а какие могут быть опущены. Этот уровень детализации в контракте интерфейса имеет решающее значение для команды разработчиков, чтобы реализовать правильную логику сериализации и десериализации, гарантируя, что API ведет себя предсказуемо при обработке сложных, вложенных наборов данных.
> - Наконец, я использую специализированные семантические форматы, которые обычно соответствуют строковым примитивам, но требуют строгого контроля для поддержания согласованности между системами. Это включает использование стандартов ISO 8601 для полей даты и времени для устранения неоднозначности часовых поясов и универсальных уникальных идентификаторов (UUID) для первичных ключей. Я также часто использую перечисления (enums) для ограничения значения поля предопределенным набором констант, таких как определенные статусы заказа, например, «В ожидании», «Отправлено» или «Доставлено». Встраивая эти конкретные типы данных и форматы в контракт API, я эффективно создаю самопроверяемую спецификацию, которая упрощает процесс приемочного тестирования пользователями (UAT) и снижает вероятность дефектов интеграции.