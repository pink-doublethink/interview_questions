---
tags:
- Technology/BA
- Difficulty/Intermediate
---
----
## Как вы реализуете асинхронное взаимодействие в REST (callbacks, polling, webhooks)
----
> [!FAQ]- Ответ
> - При определении требований к асинхронному взаимодействию в рамках RESTful-архитектуры моя основная цель — отделить запрос клиента от времени обработки на сервере, особенно для длительных операций, таких как массовый импорт данных или генерация сложных отчетов, которые могут привести к превышению времени ожидания шлюза. В таких сценариях я определяю рабочий процесс, при котором API немедленно отвечает кодом состояния HTTP 202 Accepted, вместо того чтобы заставлять клиента ждать завершения процесса. Этот первоначальный ответ обычно включает заголовок "Location" или определенный идентификатор транзакции. Моя роль заключается в анализе компромиссов между различными шаблонами реализации — в частности, опросом и веб-хуками — и документировании выбранного подхода в спецификациях API (например, OpenAPI/Swagger) и диаграммах последовательности UML для обеспечения согласованности между командами фронтенда и бэкенда.
> - Если клиент находится за строгим брандмауэром или не имеет инфраструктуры для предоставления конечной точки для прослушивания, я определяю требования к механизму "опроса". В этой модели я указываю частоту и структуру полезной нагрузки для периодического запроса клиентом конечной точки состояния до завершения задачи. Однако, чтобы уменьшить сетевой трафик и нагрузку на сервер, я обычно рекомендую использовать веб-хуки или обратные вызовы, если это позволяет инфраструктура. Для веб-хуков я разрабатываю функциональные требования, подробно описывающие, как клиент передает URL-адрес обратного вызова в полезной нагрузке первоначального запроса. Затем сервер отправляет POST-запрос на этот URL-адрес после завершения задачи. В этой документации я тщательно включаю нефункциональные требования (NFR) относительно надежности, такие как определение логики повторных попыток с экспоненциальной задержкой в ​​случае сбоя обратного вызова, и меры безопасности, такие как требование подписей HMAC для проверки того, что входящий веб-хук поступил из доверенного источника.
> - В недавнем проекте, связанном с интеграцией сторонней платежной системы, мы столкнулись с проблемами задержки, когда подтверждение платежа занимало до 45 секунд, блокируя пользовательский интерфейс. Я использовал метод STAR для решения этой проблемы, переведя архитектуру с синхронной на асинхронную с помощью веб-хуков. Я разработал схему будущего процесса, где пользовательский интерфейс немедленно освобождал бы пользователя после нажатия кнопки "Оплатить", ожидая push-уведомления от бэкенда для обновления статуса заказа. Я определил контракт данных для полезной нагрузки веб-хука и установил критерии приемлемости для граничных случаев, таких как обработка повторяющихся обратных вызовов для обеспечения идемпотентности. Этот подход не только устранил ошибки тайм-аута, которые мы наблюдали во время пользовательского приемочного тестирования (UAT), но и значительно повысил масштабируемость системы, освободив пулы потоков на сервере приложений.